Software in an application and you can't have an ad hoc development. What is ad hoc names like say for example from the C programming understanding. I'll give same DCV example. Okay. So on the prime number calculation of the prime number. So what do you know by the calculation of Pride number? If I ask you that, write a program to find out to check whether a number or given new numbers within that. How many prime numbers are there? If A and B are given, then find out all the prime numbers between A and B. What you will do, we will take A. You know that prime numbers are divisible only by itself and one. So if you are picking up A, then we'll start from two to a minus one and see if any number in between divides A in that case, if not, then it's price. So you have this understanding of directly. But what is the systematic plan way of writing the code or development is that you know that time numbers, any number that is greater than the middle number will not be able to divide the number. Let's say eight. So any number eight by four is four. So any number that is greater than four and less than eight will not divide the eight the number eight. Okay. So you will now not check for five, six, seven. You will stop at four. Okay. So that will drastically reduce your computation, isn't it? Then now you will realize I'm talking about systematic planning. Now then you will realize that what if the number is not small number like eight. It's a very huge number, let's say six, seven digit number. Okay. If you divide by two, then also it is taking a considerable amount of computation. Can I further reduce it? Then we will try to find out and know that if you take a square root of eight of the number, suppose the number is A. Then square root of A. That means you have to start from two to the square root of A. Okay. There you will find that your number of computations is drastically reduced above square root of A will not divide A. Okay. This is the mathematical probation for that. And then if you have been planning and habituated in planning, you'd realize that why do I need to start from two to root over of A? Why not directly check root over of A? It may likely happen that if you go in the reverse way of the for loop, then you will encounter the number that divides A very quickly. Okay. So now instead of going from two to root over of A, we'll start from root over of A and then try to come to in between. If any number divides A, then you exist. That's not a problem. So this is the adventure systematic development for ad hoc.